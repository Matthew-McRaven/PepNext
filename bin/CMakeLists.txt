file(GLOB_RECURSE sources_and_tests CONFIGURE_DEPENDS "${CMAKE_CURRENT_LIST_DIR}/*.cpp")
file(GLOB_RECURSE tests CONFIGURE_DEPENDS "test/*.cpp" "test/*.hpp")
file(GLOB_RECURSE compile_tests CONFIGURE_DEPENDS "compile-test/*.cpp")
file(GLOB_RECURSE demos CONFIGURE_DEPENDS "demo/*.cpp")
file(GLOB_RECURSE guis CONFIGURE_DEPENDS "gui/*.cpp")
list(APPEND sources ${sources_and_tests})
list(REMOVE_ITEM sources ${tests})
list(REMOVE_ITEM sources ${compile_tests})
list(REMOVE_ITEM sources ${demos})
list(REMOVE_ITEM sources ${guis})

# Set icon for the application if it exists.
if (EXISTS "${PROJECT_DATA_DIR}/icons/icon.ico" AND WIN32)
    LIST(APPEND sources "${PROJECT_DATA_DIR}/icons/res.rc")
elseif (EXISTS "${PROJECT_DATA_DIR}/icons/icon.icns" AND APPLE)
    #! [appicon_macOS]
    # The MACOSX_BUNDLE_ICON_FILE variable is added to the Info.plist
    # generated by CMake. This variable contains the .icns file name,
    # without the path.
    set(MACOSX_BUNDLE_ICON_FILE "icon")

    # And the following tells CMake where to find and install the file itself.
    set(app_icon_macos "${PROJECT_DATA_DIR}/icons/icon.icns")
    set_source_files_properties(${app_icon_macos} PROPERTIES MACOSX_PACKAGE_LOCATION "Resources")
    LIST(APPEND sources ${app_icon_macos})
else ()
endif ()

# Use to force terminal, test app to live in same directory.
set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY "${PROJECT_BINARY_DIR}/output")
set(CMAKE_LIBRARY_OUTPUT_DIRECTORY "${PROJECT_BINARY_DIR}/output")
set(CMAKE_RUNTIME_OUTPUT_DIRECTORY "${PROJECT_BINARY_DIR}/output")

make_target(
        TARGET pepp
        TYPE "EXEC"
        SOURCES ${sources} ${guis}
        DEPENDS
        TextFlow cli about macro pas builtins isa targets sim
        Qt6::Core Qt6::Gui Qt::Qml Qt::Quick Qt::QuickControls2
        Qt::Widgets test-lib-all memory highlight
)
target_compile_definitions(pepp PRIVATE "INCLUDE_GUI=1")
# Must occur before install scripts, otherwise MacOS builds will fail.
set_target_properties(pepp PROPERTIES
        MACOSX_BUNDLE_GUI_IDENTIFIER edu.pepperdine.cslab.pepp
        MACOSX_BUNDLE_BUNDLE_VERSION ${PROJECT_VERSION}
        MACOSX_BUNDLE_SHORT_VERSION_STRING ${PROJECT_VERSION_MAJOR}.${PROJECT_VERSION_MINOR}
        MACOSX_BUNDLE TRUE
        WIN32_EXECUTABLE TRUE
        FOLDER "qtc_runnable"
)

# Must specify antlr, because we can't easily install 3rd-party deps.
install(TARGETS pepp antlr4_shared
    COMPONENT Pepp
    RUNTIME DESTINATION bin
    BUNDLE DESTINATION .
)
if(APPLE)
    install(TARGETS antlr4_shared LIBRARY DESTINATION pepp.app/Contents/Frameworks)
endif()

qt_generate_deploy_qml_app_script(
        TARGET pepp
        OUTPUT_SCRIPT deploy_script
        NO_UNSUPPORTED_PLATFORM_ERROR
)
install(SCRIPT ${deploy_script} COMPONENT Pepp)

set(TEST_TARGET "pepp")
# Files with QML definitions must always be includeable without a prefix.
# See: https://bugreports.qt.io/browse/QTBUG-101146.
target_include_directories(pepp PRIVATE ${CMAKE_CURRENT_LIST_DIR}/demo/fig-view)

# On Windows, applications may either be GUI or terminal, not both.
# So, we (hackishly) recompile the target above, but this time we will not set WIN32_EXECUTABLE.
if (WIN32)
    make_target(
            TARGET pepp-term
            TYPE "EXEC"
            SOURCES ${sources}
            DEPENDS TextFlow cli about macro pas builtins isa targets sim Qt6::Core catch test-lib-all
    )
    install(TARGETS pepp-term DESTINATION bin COMPONENT Pepp)
    set_target_properties(pepp-term PROPERTIES FOLDER "qtc_runnable")
    target_compile_definitions(pepp-term PRIVATE "INCLUDE_GUI=0")
    target_compile_definitions(pepp-term PRIVATE "DEFAULT_GUI=0")
    target_compile_definitions(pepp PRIVATE "DEFAULT_GUI=1")
    set(TEST_TARGET "pepp-term")
    # Non-DLL platforms have empty generator expression, so use more generator magic to only copy DLLs if the exist.
    add_custom_command(TARGET pepp POST_BUILD
            COMMAND ${CMAKE_COMMAND}
            ARGS
            -E $<IF:$<BOOL:$<TARGET_RUNTIME_DLLS:pepp>>,copy,true> $<TARGET_RUNTIME_DLLS:pepp> $<TARGET_FILE_DIR:pepp>
            COMMAND_EXPAND_LISTS
    )
else ()
    target_compile_definitions(pepp PRIVATE "DEFAULT_GUI=0")
    add_executable(pepp-term ALIAS pepp)
endif ()


if (0)
    configure_file(test/config.hpp.in "${CMAKE_CURRENT_BINARY_DIR}/config.hpp")
    make_target(
            TARGET test-term
            TYPE "EXEC"
            SOURCES
            test/about.cpp
            test/asmrun.cpp
            test/ls.cpp
            test/get.cpp
            test/test_main.cpp
            test/samples.qrc
            test/samples.cpp
            DEPENDS Qt6::Core catch
    )

    # Needed to find config file.
    target_include_directories(test-term PRIVATE ${CMAKE_CURRENT_BINARY_DIR})
    add_dependencies(pepp test-term)
    option(ENABLE_TERM_TESTS "Enable shell tests of pepp" OFF)
    if (ENABLE_TERM_TESTS)
        add_test(NAME test-term COMMAND test-term)
        set_target_properties(test-term PROPERTIES FOLDER "qtc_runnable")
    endif ()
endif ()

# Add main GUI module, qml sources, resources, and add demo applications.
# GLOB_RECURSE uses abs paths, QML_FILES expects relative paths. This blob converts from abs to rel.
file(GLOB_RECURSE abs_qml_sources CONFIGURE_DEPENDS "gui/*.qml" "demo/*.qml")
SET(rel_qml_sources, "")
foreach (f_abs IN LISTS abs_qml_sources)
    file(RELATIVE_PATH f_rel "${CMAKE_CURRENT_LIST_DIR}" ${f_abs})
    list(APPEND rel_qml_sources "${f_rel}")
endforeach ()
qt_add_qml_module(pepp
        URI Pepp
        VERSION 0.2
        QML_FILES ${rel_qml_sources}
        SOURCES ${guis} ${demos}
        QML_FILES
)
qt6_add_resources(pepp "pepp"
        PREFIX
        "/"
        FILES
        ${pep10_resource_files}
)

# Set pepp/pepp-term as a test target.
if (NOT EMSCRIPTEN)
    set(count 2)
    catch_test_count(count)
    catch_add_sharded_tests(${TEST_TARGET} "selftest" SHARD_COUNT ${count})
endif ()
