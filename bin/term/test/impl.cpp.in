/*
 * Copyright (c) 2023 J. Stanley Warford, Matthew McRaven
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */


#include <QTest>
#include <QtCore>
#include <QRegularExpression>
#include <QDirIterator>
#include <QProcessEnvironment>
#include <QCoreApplication>

// Needed for python code to compile correctly.
// See: https://stackoverflow.com/a/49359288
#pragma push_macro("slots")
#undef slots
#include <Python.h>
#pragma pop_macro("slots")

class Term@NAME@ : public QObject {
    Q_OBJECT
private Q_SLOTS:
    void smoke() {
        // File written out by cmake. First line is the path of pepp terminal executable.
        // The second line is a path to a file which contains the values for PYTHONHOME and PYTHONPATH
        auto config_path = QCoreApplication::applicationDirPath()+"/test_config.txt";
        QFile config_file(config_path);
        if (!config_file.open(QIODevice::ReadOnly | QIODevice::Text))
            QVERIFY2(false, "Failed to read config file");

        // Must clear newlines, or exec will not find correct file.
        auto term_path = QString(config_file.readLine()).trimmed().toStdWString();
        static wchar_t about[] = L"@FILENAME@";

        wchar_t* argv[2];
        argv[0] = about;
        argv[1] = term_path.data();

        // Path to file with PYTHONHOME and PYTHONPATH values
        auto paths_path = QString(config_file.readLine()).trimmed();

        QFile paths_file(paths_path);
        if (!paths_file.open(QIODevice::ReadOnly | QIODevice::Text))
            QVERIFY2(false, "Failed to read paths file");
        // File is newline delimited, but newline changes based on OS, so split on any newline.
        static const QRegularExpression newline("\r\n|\r|\n");
        auto paths_text = QString(paths_file.readAll());
        // Paths file first line is PYTHONHOME
        auto home = paths_text.split(newline).first().toStdWString();
        // Entire paths file is to be the value of PYTHONPATH.
        // According to https://peps.python.org/pep-0587/, use : as DELIM
        auto pythonpath_env = paths_text.replace(newline, ":").toStdWString();




        PyStatus status;
        PyConfig config;

        // Create an initial python configwhich behaves like normal python
        PyConfig_InitPythonConfig(&config);

        // Helper to diagnose broken resources.
        // QDirIterator it(":", QDirIterator::Subdirectories);
        // while (it.hasNext()) qDebug() << it.next();
        // qDebug() << ":/py/@PY_SCRIPT@";

        // Read python program from resources.
        QFile py_script(":/py/@PY_SCRIPT@");
        if (!py_script.open(QIODevice::ReadOnly | QIODevice::Text))
            QVERIFY2(false, "Failed to read python script");
        auto program_text = QString(py_script.readAll()).toStdWString();
        config.run_command = program_text.data();


        // Update program name for our specific test.
        status = PyConfig_SetString(&config, &config.program_name, L"@NAME@");
        if (PyStatus_Exception(status)) goto fail;

        // Configure python argv so that python script can parse args.
        config.argv = PyWideStringList {.length=2, .items=argv};

        // Update PYTHONHOME and PYTHONPATH to prevent error: "Could not find platform independent libraries <prefix>"
        // Not fixing this adds pointless noise to outputs.
        config.home = home.data();
        config.pythonpath_env = pythonpath_env.data();

        // Initialize the interpreter with configs; no more config changes possible.
        status = Py_InitializeFromConfig(&config);
        if (PyStatus_Exception(status))  goto fail;
        QCOMPARE(Py_RunMain(), 0);
        // Do not clean memory allocation, or will crash.
        // PyConfig_Clear(&config);
        return;

      fail:
        Py_ExitStatusException(status);
        PyConfig_Clear(&config);
        QVERIFY2(false, "Failed to configure python");
  }
};

#include "@FILENAME@.moc"

QTEST_MAIN(Term@NAME@)
